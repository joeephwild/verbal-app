"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isValidEthNetworkURL = exports.isHttpNetworkConfig = exports.createProviders = exports.isArtifact = exports.isFactoryOptions = exports.getWalletsFromAccount = exports.isNumber = exports.isString = exports.isHardhatNetworkAccountsConfigStrings = exports.isHardhatNetworkHDAccountsConfig = void 0;
const zksync_ethers_1 = require("zksync-ethers");
const ethers_1 = require("ethers");
const constants_1 = require("./constants");
const rich_wallets_1 = require("./rich-wallets");
const errors_1 = require("./errors");
function isHardhatNetworkHDAccountsConfig(object) {
    return 'mnemonic' in object;
}
exports.isHardhatNetworkHDAccountsConfig = isHardhatNetworkHDAccountsConfig;
function isHardhatNetworkAccountsConfigStrings(object) {
    return typeof object[0] === 'string';
}
exports.isHardhatNetworkAccountsConfigStrings = isHardhatNetworkAccountsConfigStrings;
function isString(object) {
    return typeof object === 'string';
}
exports.isString = isString;
function isNumber(object) {
    return typeof object === 'number';
}
exports.isNumber = isNumber;
async function getWalletsFromAccount(hre, accounts) {
    if (!accounts || accounts === 'remote') {
        const chainId = await hre.zksyncEthers.providerL2.send('eth_chainId', []);
        if (constants_1.LOCAL_CHAIN_IDS.includes(chainId)) {
            return rich_wallets_1.richWallets.map((wallet) => new zksync_ethers_1.Wallet(wallet.privateKey, hre.zksyncEthers.providerL2).connectToL1(hre.zksyncEthers.providerL1));
        }
        return [];
    }
    if (isHardhatNetworkAccountsConfigStrings(accounts)) {
        const accountPrivateKeys = accounts;
        const wallets = accountPrivateKeys.map((accountPrivateKey) => new zksync_ethers_1.Wallet(accountPrivateKey, hre.zksyncEthers.providerL2).connectToL1(hre.zksyncEthers.providerL1));
        return wallets;
    }
    if (isHardhatNetworkHDAccountsConfig(accounts)) {
        const account = accounts;
        const wallet = zksync_ethers_1.Wallet.fromMnemonic(account.mnemonic)
            .connect(hre.zksyncEthers.providerL2)
            .connectToL1(hre.zksyncEthers.providerL1);
        return [wallet];
    }
    return [];
}
exports.getWalletsFromAccount = getWalletsFromAccount;
function isFactoryOptions(walletOrOptions) {
    if (walletOrOptions === undefined || 'provider' in walletOrOptions) {
        return false;
    }
    return true;
}
exports.isFactoryOptions = isFactoryOptions;
function isArtifact(artifact) {
    const { contractName, sourceName, abi, bytecode, deployedBytecode, linkReferences, deployedLinkReferences, factoryDeps, } = artifact;
    return (typeof contractName === 'string' &&
        typeof sourceName === 'string' &&
        Array.isArray(abi) &&
        typeof bytecode === 'string' &&
        typeof deployedBytecode === 'string' &&
        linkReferences !== undefined &&
        deployedLinkReferences !== undefined &&
        factoryDeps !== undefined);
}
exports.isArtifact = isArtifact;
function createProviders(networks, network) {
    const networkName = network.name;
    if (!network.zksync) {
        throw new errors_1.ZkSyncEthersPluginError(`Only deploying to zkSync network is supported.\nNetwork '${networkName}' in 'hardhat.config' needs to have 'zksync' flag set to 'true'.`);
    }
    if (networkName === 'hardhat') {
        return {
            ethWeb3Provider: _createDefaultEthProvider(),
            zkWeb3Provider: _createDefaultZkProvider(),
        };
    }
    const networkConfig = network.config;
    if (!isHttpNetworkConfig(networkConfig)) {
        throw new errors_1.ZkSyncEthersPluginError(`Only deploying to zkSync network is supported.\nNetwork '${networkName}' in 'hardhat.config' needs to have 'url' specified.`);
    }
    if (networkConfig.ethNetwork === undefined) {
        throw new errors_1.ZkSyncEthersPluginError(`Only deploying to zkSync network is supported.\nNetwork '${networkName}' in 'hardhat.config' needs to have 'ethNetwork' (layer 1) specified.`);
    }
    let ethWeb3Provider;
    const ethNetwork = networkConfig.ethNetwork;
    if (constants_1.SUPPORTED_L1_TESTNETS.includes(ethNetwork)) {
        ethWeb3Provider =
            ethNetwork in networks && isHttpNetworkConfig(networks[ethNetwork])
                ? new ethers_1.ethers.JsonRpcProvider(networks[ethNetwork].url)
                : ethers_1.ethers.getDefaultProvider(ethNetwork);
    }
    else {
        if (ethNetwork === 'localhost' || ethNetwork === '') {
            ethWeb3Provider = _createDefaultEthProvider();
        }
        else if (isValidEthNetworkURL(ethNetwork)) {
            ethWeb3Provider = new ethers_1.ethers.JsonRpcProvider(ethNetwork);
        }
        else {
            ethWeb3Provider =
                ethNetwork in networks && isHttpNetworkConfig(networks[ethNetwork])
                    ? new ethers_1.ethers.JsonRpcProvider(networks[ethNetwork].url)
                    : ethers_1.ethers.getDefaultProvider(ethNetwork);
        }
    }
    const zkWeb3Provider = new zksync_ethers_1.Provider(network.config.url);
    return { ethWeb3Provider, zkWeb3Provider };
}
exports.createProviders = createProviders;
function _createDefaultEthProvider() {
    return new ethers_1.ethers.JsonRpcProvider(constants_1.ETH_DEFAULT_NETWORK_RPC_URL);
}
function _createDefaultZkProvider() {
    return zksync_ethers_1.Provider.getDefaultProvider();
}
function isHttpNetworkConfig(networkConfig) {
    return 'url' in networkConfig;
}
exports.isHttpNetworkConfig = isHttpNetworkConfig;
function isValidEthNetworkURL(string) {
    try {
        new URL(string);
        return true;
    }
    catch (_) {
        return false;
    }
}
exports.isValidEthNetworkURL = isValidEthNetworkURL;
//# sourceMappingURL=utils.js.map