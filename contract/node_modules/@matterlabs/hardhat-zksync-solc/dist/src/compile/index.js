"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DockerCompiler = exports.BinaryCompiler = exports.compile = void 0;
const semver_1 = __importDefault(require("semver"));
const errors_1 = require("../errors");
const utils_1 = require("../utils");
const constants_1 = require("../constants");
const docker_1 = require("./docker");
const binary_1 = require("./binary");
async function compile(zksolcConfig, input, solcPath) {
    let compiler;
    if (zksolcConfig.settings.optimizer?.fallback_to_optimizing_for_size &&
        semver_1.default.lt(zksolcConfig.version, constants_1.ZKSOLC_COMPILER_MIN_VERSION_WITH_FALLBACK_OZ)) {
        throw new errors_1.ZkSyncSolcPluginError(`fallback_to_optimizing_for_size option in optimizer is not supported for zksolc compiler version ${zksolcConfig.version}. Please use version ${constants_1.ZKSOLC_COMPILER_MIN_VERSION_WITH_FALLBACK_OZ} or higher.`);
    }
    if (zksolcConfig.compilerSource === 'binary') {
        if (solcPath === null) {
            throw new errors_1.ZkSyncSolcPluginError('solc executable is not specified');
        }
        compiler = new BinaryCompiler(solcPath);
    }
    else if (zksolcConfig.compilerSource === 'docker') {
        compiler = await DockerCompiler.initialize(zksolcConfig);
    }
    else {
        throw new errors_1.ZkSyncSolcPluginError(`Incorrect compiler source: ${zksolcConfig.compilerSource}`);
    }
    return await compiler.compile(input, zksolcConfig);
}
exports.compile = compile;
class BinaryCompiler {
    constructor(solcPath) {
        this.solcPath = solcPath;
    }
    async compile(input, config) {
        // Check for missing libraries
        if (semver_1.default.gte(config.version, constants_1.DETECT_MISSING_LIBRARY_MODE_COMPILER_VERSION)) {
            const zkSolcOutput = await (0, binary_1.compileWithBinary)(input, config, this.solcPath, true);
            const missingLibraries = (0, utils_1.findMissingLibraries)(zkSolcOutput);
            if (missingLibraries.size > 0) {
                if (!config.settings.missingLibrariesPath) {
                    throw new errors_1.ZkSyncSolcPluginError('Missing libraries path is not specified');
                }
                const missingLibraryDependencies = (0, utils_1.mapMissingLibraryDependencies)(zkSolcOutput, missingLibraries);
                // Write missing libraries to file
                const missingLibrariesPath = config.settings.missingLibrariesPath;
                await (0, utils_1.writeLibrariesToFile)(missingLibrariesPath, missingLibraryDependencies);
                config.settings.areLibrariesMissing = true;
                return zkSolcOutput;
            }
        }
        config.settings.areLibrariesMissing = false;
        return await (0, binary_1.compileWithBinary)(input, config, this.solcPath);
    }
}
exports.BinaryCompiler = BinaryCompiler;
class DockerCompiler {
    constructor(dockerCompilerImage, docker) {
        this.dockerCompilerImage = dockerCompilerImage;
        this.docker = docker;
    }
    static async initialize(config) {
        await (0, docker_1.validateDockerIsInstalled)();
        const image = (0, docker_1.dockerImage)(config.settings.experimental?.dockerImage, config.settings.experimental?.tag);
        const docker = await (0, docker_1.createDocker)();
        await (0, docker_1.pullImageIfNecessary)(docker, image);
        return new DockerCompiler(image, docker);
    }
    async compile(input, config) {
        // We don't check here for missing libraries because docker is using older versions of zksolc and it's deprecated
        return await (0, docker_1.compileWithDocker)(input, this.docker, this.dockerCompilerImage, config);
    }
    async solcVersion() {
        const versionOutput = await (0, docker_1.getSolcVersion)(this.docker, this.dockerCompilerImage);
        const longVersion = versionOutput.match(/^Version: (.*)$/)[1];
        const version = longVersion.split('+')[0];
        return { version, longVersion };
    }
}
exports.DockerCompiler = DockerCompiler;
//# sourceMappingURL=index.js.map