"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZksolcCompilerDownloader = void 0;
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const chalk_1 = __importDefault(require("chalk"));
const child_process_1 = require("child_process");
const utils_1 = require("../utils");
const constants_1 = require("../constants");
const errors_1 = require("./../errors");
/**
 * This class is responsible for downloading the zksolc binary.
 */
class ZksolcCompilerDownloader {
    static async getDownloaderWithVersionValidated(version, configCompilerPath, compilersDir) {
        if (!ZksolcCompilerDownloader._instance) {
            let compilerVersionInfo = await ZksolcCompilerDownloader._getCompilerVersionInfo(compilersDir);
            if (compilerVersionInfo === undefined ||
                (await ZksolcCompilerDownloader._shouldDownloadCompilerVersionInfo(compilersDir))) {
                await ZksolcCompilerDownloader._downloadCompilerVersionInfo(compilersDir);
                compilerVersionInfo = await ZksolcCompilerDownloader._getCompilerVersionInfo(compilersDir);
            }
            if (compilerVersionInfo === undefined) {
                throw new errors_1.ZkSyncSolcPluginError(constants_1.COMPILER_VERSION_INFO_FILE_NOT_FOUND_ERROR);
            }
            if (version !== constants_1.ZKSOLC_COMPILER_PATH_VERSION && configCompilerPath) {
                throw new errors_1.ZkSyncSolcPluginError(`When a compiler path is provided, specifying a version of the zksolc compiler in Hardhat is not allowed. Please omit the version and try again.`);
            }
            if (version === constants_1.ZKSOLC_COMPILER_PATH_VERSION && !configCompilerPath) {
                throw new errors_1.ZkSyncSolcPluginError(`The zksolc compiler path is not specified for local or remote origin.`);
            }
            if (version === 'latest' || version === compilerVersionInfo.latest) {
                version = compilerVersionInfo.latest;
            }
            else if (version !== constants_1.ZKSOLC_COMPILER_PATH_VERSION && !(0, utils_1.isVersionInRange)(version, compilerVersionInfo)) {
                throw new errors_1.ZkSyncSolcPluginError((0, constants_1.COMPILER_VERSION_RANGE_ERROR)(version, compilerVersionInfo.minVersion, compilerVersionInfo.latest));
            }
            else if (version !== constants_1.ZKSOLC_COMPILER_PATH_VERSION) {
                console.info(chalk_1.default.yellow((0, constants_1.COMPILER_VERSION_WARNING)(version, compilerVersionInfo.latest)));
            }
            ZksolcCompilerDownloader._instance = new ZksolcCompilerDownloader(version, configCompilerPath, compilersDir);
        }
        return ZksolcCompilerDownloader._instance;
    }
    /**
     * Use `getDownloaderWithVersionValidated` to create an instance of this class.
     */
    constructor(_version, _configCompilerPath, _compilersDirectory) {
        this._version = _version;
        this._configCompilerPath = _configCompilerPath;
        this._compilersDirectory = _compilersDirectory;
        this._isCompilerPathURL = (0, utils_1.isURL)(_configCompilerPath);
    }
    getVersion() {
        return this._version;
    }
    getCompilerPath() {
        let salt = '';
        if (this._isCompilerPathURL) {
            // hashed url used as a salt to avoid name collisions
            salt = (0, utils_1.saltFromUrl)(this._configCompilerPath);
        }
        else if (this._configCompilerPath) {
            return this._configCompilerPath;
        }
        // Add mock extension '0' so windowns can run the binary
        return path_1.default.join(this._compilersDirectory, 'zksolc', `zksolc-${this._configCompilerPath ? `remote` : `v${this._version}`}${salt ? '-' : ''}${salt}${this._configCompilerPath ? '.0' : ''}`);
    }
    async isCompilerDownloaded() {
        if (this._configCompilerPath && !this._isCompilerPathURL) {
            await this._verifyCompilerAndSetVersionIfNeeded();
            return true;
        }
        if (this._configCompilerPath && this._isCompilerPathURL) {
            const compilerPathFromUrl = this.getCompilerPath();
            if (await fs_extra_1.default.pathExists(compilerPathFromUrl)) {
                await this._verifyCompilerAndSetVersionIfNeeded();
                return true;
            }
            return false;
        }
        const compilerPath = this.getCompilerPath();
        return fs_extra_1.default.pathExists(compilerPath);
    }
    static async _shouldDownloadCompilerVersionInfo(compilersDir) {
        const compilerVersionInfoPath = this._getCompilerVersionInfoPath(compilersDir);
        if (!(await fs_extra_1.default.pathExists(compilerVersionInfoPath))) {
            return true;
        }
        const stats = await fs_extra_1.default.stat(compilerVersionInfoPath);
        const age = new Date().valueOf() - stats.ctimeMs;
        return age > ZksolcCompilerDownloader.compilerVersionInfoCachePeriodMs;
    }
    static _getCompilerVersionInfoPath(compilersDir) {
        return path_1.default.join(compilersDir, 'zksolc', 'compilerVersionInfo.json');
    }
    async downloadCompiler() {
        let compilerVersionInfo = await ZksolcCompilerDownloader._getCompilerVersionInfo(this._compilersDirectory);
        if (compilerVersionInfo === undefined ||
            (await ZksolcCompilerDownloader._shouldDownloadCompilerVersionInfo(this._compilersDirectory))) {
            await ZksolcCompilerDownloader._downloadCompilerVersionInfo(this._compilersDirectory);
            compilerVersionInfo = await ZksolcCompilerDownloader._getCompilerVersionInfo(this._compilersDirectory);
        }
        if (compilerVersionInfo === undefined) {
            throw new errors_1.ZkSyncSolcPluginError(constants_1.COMPILER_VERSION_INFO_FILE_NOT_FOUND_ERROR);
        }
        if (!this._configCompilerPath && !(0, utils_1.isVersionInRange)(this._version, compilerVersionInfo)) {
            throw new errors_1.ZkSyncSolcPluginError((0, constants_1.COMPILER_VERSION_RANGE_ERROR)(this._version, compilerVersionInfo.minVersion, compilerVersionInfo.latest));
        }
        try {
            console.info(chalk_1.default.yellow(`Downloading zksolc ${!this._configCompilerPath ? this._version : 'from the remote origin'}`));
            await this._downloadCompiler();
            console.info(chalk_1.default.green(`zksolc ${!this._configCompilerPath ? `version ${this._version}` : 'from the remote origin'} successfully downloaded`));
        }
        catch (e) {
            throw new errors_1.ZkSyncSolcPluginError(e.message.split('\n')[0]);
        }
        await this._postProcessCompilerDownload();
        await this._verifyCompilerAndSetVersionIfNeeded();
    }
    /*
        Currently, the compiler version info is pulled from the constants and not from the remote origin, in the future we will allow it to be downloaded from CDN-a.
        We are currently limited in that each new version requires an update of the plugin version.
    */
    static async _downloadCompilerVersionInfo(compilersDir) {
        const latestRelease = await (0, utils_1.getLatestRelease)(constants_1.ZKSOLC_BIN_OWNER, constants_1.ZKSOLC_BIN_REPOSITORY_NAME, constants_1.USER_AGENT);
        const releaseToSave = {
            latest: latestRelease,
            minVersion: constants_1.ZKSOLC_COMPILER_VERSION_MIN_VERSION,
        };
        const savePath = this._getCompilerVersionInfoPath(compilersDir);
        await (0, utils_1.saveDataToFile)(releaseToSave, savePath);
    }
    async _downloadCompiler() {
        const downloadPath = this.getCompilerPath();
        const url = this._getCompilerUrl(true);
        try {
            await this._attemptDownload(url, downloadPath);
        }
        catch (e) {
            if (!this._isCompilerPathURL) {
                const fallbackUrl = this._getCompilerUrl(false);
                await this._attemptDownload(fallbackUrl, downloadPath);
            }
        }
        return downloadPath;
    }
    _getCompilerUrl(useGithubRelease) {
        if (this._isCompilerPathURL) {
            return this._configCompilerPath;
        }
        return (0, utils_1.getZksolcUrl)(constants_1.ZKSOLC_BIN_REPOSITORY, this._version, useGithubRelease);
    }
    async _attemptDownload(url, downloadPath) {
        return (0, utils_1.download)(url, downloadPath, constants_1.USER_AGENT, constants_1.DEFAULT_TIMEOUT_MILISECONDS);
    }
    static async _readCompilerVersionInfo(compilerVersionInfoPath) {
        return fs_extra_1.default.readJSON(compilerVersionInfoPath);
    }
    static async _getCompilerVersionInfo(compilersDir) {
        const compilerVersionInfoPath = this._getCompilerVersionInfoPath(compilersDir);
        if (!(await fs_extra_1.default.pathExists(compilerVersionInfoPath))) {
            return undefined;
        }
        return await this._readCompilerVersionInfo(compilerVersionInfoPath);
    }
    async _postProcessCompilerDownload() {
        const compilerPath = this.getCompilerPath();
        fs_extra_1.default.chmodSync(compilerPath, 0o755);
    }
    async _verifyCompilerAndSetVersionIfNeeded() {
        const compilerPath = this.getCompilerPath();
        const versionOutput = (0, child_process_1.spawnSync)(compilerPath, ['--version']);
        const version = versionOutput.stdout
            ?.toString()
            .match(/\d+\.\d+\.\d+/)
            ?.toString();
        if (versionOutput.status !== 0 || version === null) {
            throw new errors_1.ZkSyncSolcPluginError((0, constants_1.COMPILER_BINARY_CORRUPTION_ERROR)(compilerPath));
        }
        if (this._configCompilerPath) {
            this._version = version;
        }
    }
}
exports.ZksolcCompilerDownloader = ZksolcCompilerDownloader;
ZksolcCompilerDownloader.compilerVersionInfoCachePeriodMs = constants_1.DEFAULT_COMPILER_VERSION_INFO_CACHE_PERIOD;
//# sourceMappingURL=downloader.js.map