"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractModule = exports.getConstructorArguments = exports.retrieveContractBytecode = exports.getWalletsFromAccount = exports.isNumber = exports.isString = exports.isHardhatNetworkAccountsConfigStrings = exports.isHardhatNetworkHDAccountsConfig = exports.compileContracts = exports.isValidEthNetworkURL = exports.removeLibraryInfoFile = exports.getLibraryInfos = exports.fillLibrarySettings = exports.generateFullQuailfiedNameString = exports.updateHardhatConfigFile = exports.isHttpNetworkConfig = void 0;
const task_names_1 = require("hardhat/builtin-tasks/task-names");
const fs_1 = __importDefault(require("fs"));
const zksync_ethers_1 = require("zksync-ethers");
const morph_ts_builder_1 = require("./morph-ts-builder");
const errors_1 = require("./errors");
const constants_1 = require("./constants");
const rich_wallets_1 = require("./rich-wallets");
function isHttpNetworkConfig(networkConfig) {
    return 'url' in networkConfig;
}
exports.isHttpNetworkConfig = isHttpNetworkConfig;
function updateHardhatConfigFile(hre, externalConfigObjectPath, exportedConfigObject) {
    try {
        new morph_ts_builder_1.MorphTsBuilder(externalConfigObjectPath ?? hre.config.paths.configFile)
            .intialStep([
            { initialModule: 'module.exports' },
            {},
            { initialVariableType: 'HardhatUserConfig' },
            { initialVariable: exportedConfigObject },
        ])
            .nextStep({ propertyName: 'zksolc' })
            .nextStep({ propertyName: 'settings' })
            .replaceStep({ propertyName: 'libraries', replaceObject: hre.config.zksolc.settings.libraries })
            .save();
    }
    catch (error) {
        throw new errors_1.ZkSyncDeployPluginError('Failed to update hardhat config file, please use addresses from console output');
    }
}
exports.updateHardhatConfigFile = updateHardhatConfigFile;
function generateFullQuailfiedNameString(contractFQN) {
    return `${contractFQN.contractPath}:${contractFQN.contractName}`;
}
exports.generateFullQuailfiedNameString = generateFullQuailfiedNameString;
async function fillLibrarySettings(hre, libraries) {
    libraries.forEach((library) => {
        const contractPath = library.contractFQN.contractPath;
        const contractName = library.contractFQN.contractName;
        if (!hre.config.zksolc.settings.libraries) {
            hre.config.zksolc.settings.libraries = {};
        }
        hre.config.zksolc.settings.libraries[contractPath] = {
            [contractName]: library.address,
        };
    });
}
exports.fillLibrarySettings = fillLibrarySettings;
function getLibraryInfos(hre) {
    const libraryPathFile = hre.config.zksolc.settings.missingLibrariesPath;
    if (!fs_1.default.existsSync(libraryPathFile)) {
        throw new errors_1.ZkSyncDeployPluginError('Missing libraries file not found');
    }
    return JSON.parse(fs_1.default.readFileSync(libraryPathFile, 'utf8'));
}
exports.getLibraryInfos = getLibraryInfos;
function removeLibraryInfoFile(hre) {
    const libraryPathFile = hre.config.zksolc.settings.missingLibrariesPath;
    if (fs_1.default.existsSync(libraryPathFile)) {
        fs_1.default.rmSync(libraryPathFile);
    }
}
exports.removeLibraryInfoFile = removeLibraryInfoFile;
function isValidEthNetworkURL(string) {
    try {
        new URL(string);
        return true;
    }
    catch (_) {
        return false;
    }
}
exports.isValidEthNetworkURL = isValidEthNetworkURL;
async function compileContracts(hre, contracts) {
    hre.config.zksolc.settings.contractsToCompile = contracts;
    await hre.run(task_names_1.TASK_COMPILE, { force: true });
}
exports.compileContracts = compileContracts;
function isHardhatNetworkHDAccountsConfig(object) {
    return 'mnemonic' in object;
}
exports.isHardhatNetworkHDAccountsConfig = isHardhatNetworkHDAccountsConfig;
function isHardhatNetworkAccountsConfigStrings(object) {
    return typeof object[0] === 'string';
}
exports.isHardhatNetworkAccountsConfigStrings = isHardhatNetworkAccountsConfigStrings;
function isString(object) {
    return typeof object === 'string';
}
exports.isString = isString;
function isNumber(object) {
    return typeof object === 'number';
}
exports.isNumber = isNumber;
async function getWalletsFromAccount(hre, accounts) {
    if (!accounts || accounts === 'remote') {
        const chainId = await hre.network.provider.send('eth_chainId', []);
        if (constants_1.LOCAL_CHAIN_IDS.includes(chainId)) {
            return rich_wallets_1.richWallets.map((wallet) => new zksync_ethers_1.Wallet(wallet.privateKey));
        }
        return [];
    }
    if (isHardhatNetworkAccountsConfigStrings(accounts)) {
        const accountPrivateKeys = accounts;
        const wallets = accountPrivateKeys.map((accountPrivateKey) => new zksync_ethers_1.Wallet(accountPrivateKey));
        return wallets;
    }
    if (isHardhatNetworkHDAccountsConfig(accounts)) {
        const account = accounts;
        const wallet = zksync_ethers_1.Wallet.fromMnemonic(account.mnemonic);
        return [wallet];
    }
    return [];
}
exports.getWalletsFromAccount = getWalletsFromAccount;
async function retrieveContractBytecode(address, provider) {
    const bytecodeString = (await provider.send('eth_getCode', [address, 'latest']));
    if (!bytecodeString || bytecodeString.length === 0) {
        return undefined;
    }
    return bytecodeString;
}
exports.retrieveContractBytecode = retrieveContractBytecode;
async function getConstructorArguments(constructorArgsParams, constructorArgsModule) {
    if (typeof constructorArgsModule !== 'string') {
        return constructorArgsParams;
    }
    const constructorArgsModulePath = path.resolve(process.cwd(), constructorArgsModule);
    try {
        const constructorArguments = await extractModule(constructorArgsModulePath);
        if (!Array.isArray(constructorArguments) && !constructorArguments.startsWith('0x')) {
            throw new ZkSyncVerifyPluginError(ENCODED_ARAGUMENTS_NOT_FOUND_ERROR(constructorArgsModulePath));
        }
        return constructorArguments;
    }
    catch (error) {
        throw new ZkSyncVerifyPluginError(CONSTRUCTOR_MODULE_IMPORTING_ERROR(error.message), error);
    }
}
exports.getConstructorArguments = getConstructorArguments;
async function extractModule(constructorArgsModulePath) {
    const constructorArguments = (await Promise.resolve(`${constructorArgsModulePath}`).then(s => __importStar(require(s)))).default;
    return constructorArguments;
}
exports.extractModule = extractModule;
//# sourceMappingURL=utils.js.map