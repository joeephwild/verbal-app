"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.deployContract = exports.getNetworkAccount = exports.getWallets = exports.getWallet = exports.deployLibraries = void 0;
const chalk_1 = __importDefault(require("chalk"));
const zksync_ethers_1 = require("zksync-ethers");
const task_names_1 = require("hardhat/builtin-tasks/task-names");
const errors_1 = require("./errors");
const deployer_1 = require("./deployer");
const utils_1 = require("./utils");
async function deployLibraries(hre, privateKeyOrAccountNumber, externalConfigObjectPath, exportedConfigObject, noAutoPopulateConfig, compileAllContracts) {
    const wallet = await getWallet(hre, privateKeyOrAccountNumber ?? getNetworkAccount(hre));
    const deployer = new deployer_1.Deployer(hre, wallet);
    const libraryInfos = (0, utils_1.getLibraryInfos)(hre);
    const allDeployedLibraries = [];
    // @ts-ignore
    hre.config.zksolc.settings.contractsToCompile = [];
    for (const libraryInfo of libraryInfos) {
        const compileInfo = await deployLibrary(hre, deployer, libraryInfo, libraryInfos, allDeployedLibraries);
        const _ = (0, utils_1.fillLibrarySettings)(hre, [compileInfo]);
    }
    console.info(chalk_1.default.green('All libraries deployed successfully!'));
    if (!noAutoPopulateConfig) {
        (0, utils_1.updateHardhatConfigFile)(hre, externalConfigObjectPath, exportedConfigObject);
    }
    (0, utils_1.removeLibraryInfoFile)(hre);
    if (compileAllContracts) {
        console.info(chalk_1.default.yellow('Compiling all contracts'));
        await (0, utils_1.compileContracts)(hre, []);
    }
    else {
        console.info(chalk_1.default.yellow(`Please run ${chalk_1.default.green('yarn hardhat compile')} to compile all contracts`));
    }
}
exports.deployLibraries = deployLibraries;
async function deployLibrary(hre, deployer, missingLibrary, missingLibraries, allDeployedLibraries) {
    const deployedLibrary = allDeployedLibraries.find((deplLibrary) => (0, utils_1.generateFullQuailfiedNameString)(missingLibrary).includes((0, utils_1.generateFullQuailfiedNameString)(deplLibrary.contractFQN)));
    if (deployedLibrary) {
        return deployedLibrary;
    }
    const contractFQN = {
        contractName: missingLibrary.contractName,
        contractPath: missingLibrary.contractPath,
    };
    if (missingLibrary.missingLibraries.length === 0) {
        return await compileAndDeploy(hre, deployer, contractFQN, allDeployedLibraries);
    }
    const dependentLibraries = findDependentLibraries(missingLibrary.missingLibraries, missingLibraries);
    const contractInfos = await Promise.all(Array.from(dependentLibraries).map(async (dependentLibrary) => deployLibrary(hre, deployer, dependentLibrary, missingLibraries, allDeployedLibraries)));
    const _ = (0, utils_1.fillLibrarySettings)(hre, contractInfos);
    return await compileAndDeploy(hre, deployer, contractFQN, allDeployedLibraries);
}
function findDependentLibraries(dependentLibraries, missingLibraries) {
    return dependentLibraries.map((dependentLibrary) => {
        const dependentFQNString = dependentLibrary.split(':');
        const dependentFQN = {
            contractName: dependentFQNString[1],
            contractPath: dependentFQNString[0],
        };
        const foundMissingLibrary = missingLibraries.find((missingLibrary) => (0, utils_1.generateFullQuailfiedNameString)(missingLibrary).includes((0, utils_1.generateFullQuailfiedNameString)(dependentFQN)));
        if (!foundMissingLibrary) {
            throw new errors_1.ZkSyncDeployPluginError(`Missing library ${dependentLibrary} not found`);
        }
        return foundMissingLibrary;
    });
}
async function deployOneLibrary(deployer, contractFQN, allDeployedLibraries) {
    const artifact = await deployer.loadArtifact((0, utils_1.generateFullQuailfiedNameString)(contractFQN));
    console.info(chalk_1.default.yellow(`Deploying ${(0, utils_1.generateFullQuailfiedNameString)(contractFQN)} .....`));
    const contract = await deployer.deploy(artifact, []);
    console.info(chalk_1.default.green(`Deployed ${(0, utils_1.generateFullQuailfiedNameString)(contractFQN)} at ${await contract.getAddress()}`));
    const contractInfo = {
        contractFQN,
        address: await contract.getAddress(),
    };
    allDeployedLibraries.push(contractInfo);
    return contractInfo;
}
async function compileAndDeploy(hre, deployer, contractFQN, allDeployedLibraries) {
    await (0, utils_1.compileContracts)(hre, [contractFQN.contractPath]);
    return await deployOneLibrary(deployer, contractFQN, allDeployedLibraries);
}
async function getWallet(hre, privateKeyOrIndex) {
    const privateKey = (0, utils_1.isString)(privateKeyOrIndex) ? privateKeyOrIndex : undefined;
    const accountNumber = (0, utils_1.isNumber)(privateKeyOrIndex) ? privateKeyOrIndex : undefined;
    if (privateKey) {
        return new zksync_ethers_1.Wallet(privateKey);
    }
    const accounts = hre.network.config.accounts;
    const wallets = await (0, utils_1.getWalletsFromAccount)(hre, accounts);
    if (accountNumber && accountNumber >= wallets.length) {
        throw new errors_1.ZkSyncDeployPluginError('Account private key with specified index is not found');
    }
    if (wallets.length === 0) {
        throw new errors_1.ZkSyncDeployPluginError('Accounts are not configured for this network');
    }
    return wallets[accountNumber || 0];
}
exports.getWallet = getWallet;
async function getWallets(hre) {
    const accounts = hre.network.config.accounts;
    return await (0, utils_1.getWalletsFromAccount)(hre, accounts);
}
exports.getWallets = getWallets;
function getNetworkAccount(hre) {
    const networkName = hre.network.name;
    return hre.config.deployerAccounts[networkName] ?? hre.config.deployerAccounts.default ?? 0;
}
exports.getNetworkAccount = getNetworkAccount;
async function deployContract(hre, taskArgs) {
    if (!taskArgs.noCompile) {
        await hre.run(task_names_1.TASK_COMPILE);
    }
    const constructorArguments = await (0, utils_1.getConstructorArguments)(taskArgs.constructorArgsParams, taskArgs.constructorArgs);
    const contract = await hre.deployer.deploy(taskArgs.contractName, constructorArguments, taskArgs.deploymentType, {
        customData: {
            salt: taskArgs.salt,
        },
    });
    console.log(chalk_1.default.green(`Contract ${taskArgs.contractName} deployed at ${await contract.getAddress()}`));
    return contract;
}
exports.deployContract = deployContract;
//# sourceMappingURL=plugin.js.map