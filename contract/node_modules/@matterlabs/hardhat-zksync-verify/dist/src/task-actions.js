"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getContractInfo = exports.verifyContract = exports.getConstructorArguments = exports.getCompilerVersions = exports.verify = void 0;
const contract_names_1 = require("hardhat/utils/contract-names");
const chalk_1 = __importDefault(require("chalk"));
const path_1 = __importDefault(require("path"));
const utils_1 = require("@matterlabs/hardhat-zksync-solc/dist/src/utils");
const constants_1 = require("@matterlabs/hardhat-zksync-solc/dist/src/constants");
const service_1 = require("./zksync-block-explorer/service");
const constants_2 = require("./constants");
const utils_2 = require("./utils");
const errors_1 = require("./errors");
const bytecode_1 = require("./solc/bytecode");
const plugin_1 = require("./plugin");
const config_extractor_1 = require("./config-extractor");
async function verify(args, hre, runSuper) {
    if (!hre.network.zksync) {
        return await runSuper(args);
    }
    if (hre.network.verifyURL === undefined) {
        hre.network.verifyURL = constants_2.TESTNET_VERIFY_URL;
    }
    if (args.address === undefined) {
        throw new errors_1.ZkSyncVerifyPluginError(constants_2.NO_VERIFIABLE_ADDRESS_ERROR);
    }
    const constructorArguments = await hre.run(constants_2.TASK_VERIFY_GET_CONSTRUCTOR_ARGUMENTS, {
        constructorArgsModule: args.constructorArgs,
        constructorArgsParams: args.constructorArgsParams,
    });
    const libraries = await (0, plugin_1.getLibraries)(args.libraries);
    await hre.run(constants_2.TASK_VERIFY_VERIFY, {
        address: args.address,
        constructorArguments,
        contract: args.contract,
        libraries,
        noCompile: args.noCompile,
    });
}
exports.verify = verify;
const extractors = [
    new config_extractor_1.SolcStringUserConfigExtractor(),
    new config_extractor_1.SolcSoloUserConfigExtractor(),
    new config_extractor_1.SolcMultiUserConfigExtractor(),
];
async function getCompilerVersions(_, hre, runSuper) {
    if (!hre.network.zksync) {
        return await runSuper();
    }
    const userSolidityConfig = hre.userConfig.solidity;
    const zkSolcConfig = hre.config.zksolc;
    if (zkSolcConfig.version === constants_1.ZKSOLC_COMPILER_PATH_VERSION) {
        throw new errors_1.ZkSyncVerifyPluginError(constants_2.USING_COMPILER_PATH_ERROR);
    }
    const extractedConfigs = extractors
        .find((extractor) => extractor.suitable(userSolidityConfig))
        ?.extract(userSolidityConfig);
    const latestEraVersion = await (0, utils_1.getLatestEraVersion)();
    const compilerVersions = hre.config.solidity.compilers.map((c) => (0, utils_2.normalizeCompilerVersions)({ compiler: c }, zkSolcConfig, latestEraVersion, extractedConfigs?.compilers ?? []) ?? c.version);
    if (hre.config.solidity.overrides !== undefined) {
        for (const [file, compiler] of Object.entries(hre.config.solidity.overrides)) {
            compilerVersions.push((0, utils_2.normalizeCompilerVersions)({ compiler, file }, zkSolcConfig, latestEraVersion, extractedConfigs?.overides ?? new Map()) ?? compiler.version);
        }
    }
    return compilerVersions;
}
exports.getCompilerVersions = getCompilerVersions;
async function getConstructorArguments(args, hre, runSuper) {
    if (!hre.network.zksync) {
        return await runSuper(args);
    }
    if (typeof args.constructorArgsModule !== 'string') {
        return args.constructorArgsParams;
    }
    const constructorArgsModulePath = path_1.default.resolve(process.cwd(), args.constructorArgsModule);
    try {
        const constructorArguments = await (0, utils_2.extractModule)(constructorArgsModulePath);
        // Since our plugin supports both encoded and decoded constructor arguments, we need to check how are they passed
        if (!Array.isArray(constructorArguments) && !constructorArguments.startsWith('0x')) {
            throw new errors_1.ZkSyncVerifyPluginError((0, constants_2.ENCODED_ARAGUMENTS_NOT_FOUND_ERROR)(constructorArgsModulePath));
        }
        return constructorArguments;
    }
    catch (error) {
        throw new errors_1.ZkSyncVerifyPluginError((0, constants_2.CONSTRUCTOR_MODULE_IMPORTING_ERROR)(error.message), error);
    }
}
exports.getConstructorArguments = getConstructorArguments;
async function verifyContract({ address, contract: contractFQN, constructorArguments, libraries, noCompile }, hre, runSuper) {
    if (!hre.network.zksync) {
        return await runSuper({ address, contractFQN, constructorArguments, libraries });
    }
    const { isAddress } = await Promise.resolve().then(() => __importStar(require('@ethersproject/address')));
    if (!isAddress(address)) {
        throw new errors_1.ZkSyncVerifyPluginError(`${address} is an invalid address.`);
    }
    const deployedBytecodeHex = await (0, utils_2.retrieveContractBytecode)(address, hre);
    const deployedBytecode = new bytecode_1.Bytecode(deployedBytecodeHex);
    if (!noCompile) {
        await hre.run(constants_2.TASK_COMPILE, { quiet: true });
    }
    const compilerVersions = await hre.run(constants_2.TASK_VERIFY_GET_COMPILER_VERSIONS);
    const contractInformation = await hre.run(constants_2.TASK_VERIFY_GET_CONTRACT_INFORMATION, {
        contractFQN,
        deployedBytecode,
        matchingCompilerVersions: compilerVersions,
        libraries,
    });
    const optimizationUsed = contractInformation.compilerInput.settings.optimizer.enabled ?? false;
    const solcVersion = contractInformation.solcVersion;
    let deployArgumentsEncoded;
    if (!Array.isArray(constructorArguments)) {
        if (constructorArguments.startsWith('0x')) {
            deployArgumentsEncoded = constructorArguments;
        }
        else {
            throw new errors_1.ZkSyncVerifyPluginError(chalk_1.default.red(constants_2.CONST_ARGS_ARRAY_ERROR));
        }
    }
    else {
        deployArgumentsEncoded = `0x${await (0, utils_2.encodeArguments)(contractInformation.contractOutput.abi, constructorArguments)}`;
    }
    const compilerPossibleVersions = await (0, service_1.getSupportedCompilerVersions)(hre.network.verifyURL);
    const compilerVersion = contractInformation.solcVersion;
    if (!compilerPossibleVersions.includes(compilerVersion)) {
        throw new errors_1.ZkSyncVerifyPluginError(constants_2.COMPILER_VERSION_NOT_SUPPORTED);
    }
    const compilerZksolcVersion = `v${contractInformation.contractOutput.metadata.zk_version}`;
    contractInformation.contractName = `${contractInformation.sourceName}:${contractInformation.contractName}`;
    const request = {
        contractAddress: address,
        sourceCode: (0, plugin_1.getSolidityStandardJsonInput)(hre, await (0, plugin_1.getMinimalResolvedFiles)(hre, contractInformation.sourceName), contractInformation.compilerInput),
        codeFormat: constants_2.JSON_INPUT_CODE_FORMAT,
        contractName: contractInformation.contractName,
        compilerSolcVersion: solcVersion,
        compilerZksolcVersion,
        constructorArguments: deployArgumentsEncoded,
        optimizationUsed,
    };
    const response = await (0, service_1.verifyContractRequest)(request, hre.network.verifyURL);
    const verificationId = parseInt(response.message, 10);
    console.info(chalk_1.default.cyan(`Your verification ID is: ${verificationId}`));
    try {
        await hre.run(constants_2.TASK_CHECK_VERIFICATION_STATUS, { verificationId });
    }
    catch (error) {
        // The first verirication attempt with 'minimal' source code was unnsuccessful.
        // Now try with the full source code from the compilation context.
        if (error.message !== constants_2.NO_MATCHING_CONTRACT &&
            constants_2.COMPILATION_ERRORS.filter((compilationError) => compilationError.pattern.test(error.message)).length === 0) {
            throw error;
        }
        console.info(chalk_1.default.red(constants_2.UNSUCCESSFUL_CONTEXT_COMPILATION_MESSAGE));
        request.sourceCode.sources = contractInformation.compilerInput.sources;
        const fallbackResponse = await (0, service_1.verifyContractRequest)(request, hre.network.verifyURL);
        const fallbackVerificationId = parseInt(fallbackResponse.message, 10);
        console.info(chalk_1.default.cyan(`Your verification ID is: ${fallbackVerificationId}`));
        await hre.run(constants_2.TASK_CHECK_VERIFICATION_STATUS, { verificationId: fallbackVerificationId });
    }
    return verificationId;
}
exports.verifyContract = verifyContract;
async function getContractInfo({ contractFQN, deployedBytecode, matchingCompilerVersions, libraries }, hre, runSuper) {
    if (!hre.network.zksync) {
        return await runSuper({ contractFQN, deployedBytecode, matchingCompilerVersions, libraries });
    }
    const artifacts = hre.artifacts;
    let contractInformation;
    if (contractFQN !== undefined) {
        const _ = (0, plugin_1.checkContractName)(artifacts, contractFQN);
        // Process BuildInfo here to check version and throw an error if unexpected version is found.
        const buildInfo = await artifacts.getBuildInfo(contractFQN);
        if (buildInfo === undefined) {
            throw new errors_1.ZkSyncVerifyPluginError((0, constants_2.BUILD_INFO_NOT_FOUND_ERROR)(contractFQN));
        }
        const { sourceName, contractName } = (0, contract_names_1.parseFullyQualifiedName)(contractFQN);
        contractInformation = await (0, bytecode_1.extractMatchingContractInformation)(sourceName, contractName, buildInfo, deployedBytecode);
        if (contractInformation === undefined || contractInformation === null) {
            throw new errors_1.ZkSyncVerifyPluginError(constants_2.NO_MATCHING_CONTRACT);
        }
    }
    else {
        contractInformation = await (0, plugin_1.inferContractArtifacts)(artifacts, matchingCompilerVersions, deployedBytecode);
    }
    return contractInformation;
}
exports.getContractInfo = getContractInfo;
//# sourceMappingURL=task-actions.js.map