"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isDevelopmentNetwork = exports.fetchOrDeployAdmin = exports.mergeAddresses = exports.fetchOrDeployGetDeployment = exports.fetchOrDeploy = exports.deleteDeployment = void 0;
const upgrades_core_1 = require("@openzeppelin/upgrades-core");
const assert_1 = __importDefault(require("assert"));
const manifest_1 = require("./manifest");
const provider_1 = require("./provider");
async function fetchOrDeployGeneric(
// eslint-disable-next-line @typescript-eslint/no-shadow
lens, provider, deploy, opts, merge) {
    const manifest = await manifest_1.Manifest.forNetwork(provider);
    try {
        const deployment = await manifest.lockedRun(async () => {
            const data = await manifest.read();
            const deploymentInternal = lens(data);
            if (merge && !deploymentInternal.merge) {
                throw new Error('fetchOrDeployGeneric was called with merge set to true but the deployment lens does not have a merge function');
            }
            const stored = deploymentInternal.get();
            const updated = await (0, upgrades_core_1.resumeOrDeploy)(provider, stored, deploy, lens.type, opts, deploymentInternal, merge);
            if (updated !== stored) {
                if (merge && deploymentInternal.merge) {
                    await checkForAddressClash(provider, data, updated, false);
                    deploymentInternal.merge(updated);
                }
                else {
                    await checkForAddressClash(provider, data, updated, true);
                    deploymentInternal.set(updated);
                }
                await manifest.write(data);
            }
            return updated;
        });
        await (0, upgrades_core_1.waitAndValidateDeployment)(provider, deployment, lens.type, opts);
        return deployment;
    }
    catch (e) {
        if (e instanceof upgrades_core_1.InvalidDeployment) {
            await manifest.lockedRun(async () => {
                (0, assert_1.default)(e instanceof upgrades_core_1.InvalidDeployment);
                const data = await manifest.read();
                const deployment = lens(data);
                const stored = deployment.get();
                if (stored?.txHash === e.deployment.txHash) {
                    deployment.set(undefined);
                    await manifest.write(data);
                }
            });
            e.removed = true;
        }
        throw e;
    }
}
function deleteDeployment(deployment) {
    deployment.set(undefined);
}
exports.deleteDeployment = deleteDeployment;
async function fetchOrDeploy(version, provider, deploy, opts, merge) {
    return (await fetchOrDeployGeneric(implLens(version.linkedWithoutMetadata), provider, deploy, opts, merge)).address;
}
exports.fetchOrDeploy = fetchOrDeploy;
async function fetchOrDeployGetDeployment(version, provider, deploy, opts, merge) {
    return fetchOrDeployGeneric(implLens(version.linkedWithoutMetadata), provider, deploy, opts, merge);
}
exports.fetchOrDeployGetDeployment = fetchOrDeployGetDeployment;
const implLens = (versionWithoutMetadata) => lens(`implementation ${versionWithoutMetadata}`, 'implementation', (data) => ({
    get: () => data.impls[versionWithoutMetadata],
    set: (value) => (data.impls[versionWithoutMetadata] = value),
    merge: (value) => {
        const existing = data.impls[versionWithoutMetadata];
        if (existing !== undefined && value !== undefined) {
            const { address, allAddresses } = mergeAddresses(existing, value);
            data.impls[versionWithoutMetadata] = { ...existing, address, allAddresses };
        }
        else {
            data.impls[versionWithoutMetadata] = value;
        }
    },
}));
function mergeAddresses(existing, value) {
    const merged = new Set();
    merged.add(existing.address);
    merged.add(value.address);
    existing.allAddresses?.forEach((item) => merged.add(item));
    value.allAddresses?.forEach((item) => merged.add(item));
    return { address: existing.address, allAddresses: Array.from(merged) };
}
exports.mergeAddresses = mergeAddresses;
async function fetchOrDeployAdmin(provider, deploy, opts) {
    return (await fetchOrDeployGeneric(adminLens, provider, deploy, opts)).address;
}
exports.fetchOrDeployAdmin = fetchOrDeployAdmin;
const adminLens = lens('proxy admin', 'proxy admin', (data) => ({
    get: () => data.admin,
    set: (value) => (data.admin = value),
}));
function lens(description, type, fn) {
    return Object.assign(fn, { description, type });
}
async function isDevelopmentNetwork(provider) {
    const chainId = await (0, provider_1.getChainId)(provider);
    if (chainId === 1337 || chainId === 31337) {
        return true;
    }
    else {
        const clientVersion = await (0, upgrades_core_1.getClientVersion)(provider);
        const [name] = clientVersion.split('/', 1);
        return name === 'HardhatNetwork' || name === 'EthereumJS TestRPC' || name === 'anvil';
    }
}
exports.isDevelopmentNetwork = isDevelopmentNetwork;
async function checkForAddressClash(provider, data, updated, checkAllAddresses) {
    const clash = lookupDeployment(data, updated.address, checkAllAddresses);
    if (clash !== undefined) {
        if (await isDevelopmentNetwork(provider)) {
            clash.set(undefined);
        }
        else {
            throw new Error(`The following deployment clashes with an existing one at ${updated.address}\n\n${JSON.stringify(updated, null, 2)}\n\n`);
        }
    }
}
function lookupDeployment(data, address, checkAllAddresses) {
    if (data.admin?.address === address) {
        return adminLens(data);
    }
    for (const versionWithoutMetadata in data.impls) {
        if (data.impls[versionWithoutMetadata]?.address === address ||
            (checkAllAddresses && data.impls[versionWithoutMetadata]?.allAddresses?.includes(address))) {
            return implLens(versionWithoutMetadata)(data);
        }
    }
}
//# sourceMappingURL=impl-store.js.map