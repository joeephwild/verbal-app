"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizeManifestData = exports.migrateManifest = exports.Manifest = exports.DeploymentNotFound = void 0;
const path_1 = __importDefault(require("path"));
const fs_1 = require("fs");
const proper_lockfile_1 = __importDefault(require("proper-lockfile"));
const compare_versions_1 = require("compare-versions");
const utils_general_1 = require("../utils/utils-general");
const constants_1 = require("../constants");
const errors_1 = require("../errors");
const provider_1 = require("./provider");
const currentManifestVersion = '3.2';
class DeploymentNotFound extends errors_1.ZkSyncUpgradablePluginError {
}
exports.DeploymentNotFound = DeploymentNotFound;
function defaultManifest() {
    return {
        manifestVersion: currentManifestVersion,
        impls: {},
        proxies: [],
    };
}
class Manifest {
    static async forNetwork(provider) {
        const chainId = await (0, provider_1.getChainId)(provider);
        return new Manifest(chainId);
    }
    constructor(chainId) {
        this.locked = false;
        this.chainId = chainId;
        this.chainIdSuffix = `${chainId}`;
        this.dir = constants_1.MANIFEST_DEFAULT_DIR;
        const defaultFallbackName = `unknown-network-${chainId}`;
        const networkName = provider_1.networkNames[chainId] !== undefined ? provider_1.networkNames[chainId] : defaultFallbackName;
        this.file = path_1.default.join(constants_1.MANIFEST_DEFAULT_DIR, `${networkName}.json`);
    }
    async getAdmin() {
        return (await this.read()).admin;
    }
    async getDeploymentFromAddress(address) {
        const data = await this.read();
        const deployment = Object.values(data.impls).find((d) => d?.address === address || d?.allAddresses?.includes(address));
        if (deployment === undefined) {
            throw new DeploymentNotFound(`Deployment at address ${address} is not registered`);
        }
        return deployment;
    }
    async getProxyFromAddress(address) {
        const data = await this.read();
        const deployment = data.proxies.find((d) => d?.address === address);
        if (deployment === undefined) {
            throw new DeploymentNotFound(`Proxy at address ${address} is not registered`);
        }
        return deployment;
    }
    async addProxy(proxy) {
        await this.lockedRun(async () => {
            const data = await this.read();
            const existing = data.proxies.findIndex((p) => p.address === proxy.address);
            if (existing >= 0) {
                data.proxies.splice(existing, 1);
            }
            data.proxies.push(proxy);
            await this.write(data);
        });
    }
    async _readFile() {
        return await fs_1.promises.readFile(this.file, 'utf8');
    }
    async _writeFile(content) {
        await fs_1.promises.writeFile(this.file, content);
    }
    async read(retries) {
        const release = this.locked ? undefined : await this._lock(retries);
        try {
            const data = JSON.parse(await this._readFile());
            return validateOrUpdateManifestVersion(data);
        }
        catch (e) {
            if (e.code === 'ENOENT') {
                if (this.parent !== undefined) {
                    return await this.parent.read(retries);
                }
                else {
                    return defaultManifest();
                }
            }
            else {
                throw e;
            }
        }
        finally {
            await release?.();
        }
    }
    async write(data) {
        if (!this.locked) {
            throw new errors_1.ZkSyncUpgradablePluginError('Manifest must be locked');
        }
        const normalized = normalizeManifestData(data);
        await this._writeFile(`${JSON.stringify(normalized, null, 2)}\n`);
    }
    async lockedRun(cb) {
        if (this.locked) {
            throw new errors_1.ZkSyncUpgradablePluginError('Manifest is already locked');
        }
        const release = await this._lock();
        try {
            return await cb();
        }
        finally {
            await release();
        }
    }
    async _lock(retries = 3) {
        const lockfileName = path_1.default.join(this.dir, `chain-${this.chainIdSuffix}`);
        await fs_1.promises.mkdir(path_1.default.dirname(lockfileName), { recursive: true });
        const release = await proper_lockfile_1.default.lock(lockfileName, { retries, realpath: false });
        this.locked = true;
        return async () => {
            await release();
            this.locked = false;
        };
    }
}
exports.Manifest = Manifest;
function validateOrUpdateManifestVersion(data) {
    if (typeof data.manifestVersion !== 'string') {
        throw new errors_1.ZkSyncUpgradablePluginError('Manifest version is missing');
    }
    else if ((0, compare_versions_1.compare)(data.manifestVersion, '3.0', '<')) {
        throw new errors_1.ZkSyncUpgradablePluginError('Found a manifest file for OpenZeppelin CLI. An automated migration is not yet available.');
    }
    else if ((0, compare_versions_1.compare)(data.manifestVersion, currentManifestVersion, '<')) {
        return migrateManifest(data);
    }
    else if (data.manifestVersion === currentManifestVersion) {
        return data;
    }
    else {
        throw new errors_1.ZkSyncUpgradablePluginError(`Unknown value for manifest version (${data.manifestVersion})`);
    }
}
function migrateManifest(data) {
    switch (data.manifestVersion) {
        case '3.0':
        case '3.1':
            data.manifestVersion = currentManifestVersion;
            data.proxies = [];
            return data;
        default:
            throw new errors_1.ZkSyncUpgradablePluginError('Manifest migration not available');
    }
}
exports.migrateManifest = migrateManifest;
function normalizeManifestData(input) {
    return {
        manifestVersion: input.manifestVersion,
        admin: input.admin && normalizeDeployment(input.admin),
        proxies: input.proxies.map((p) => normalizeDeployment(p, ['kind'])),
        impls: (0, utils_general_1.mapValues)(input.impls, (i) => i && normalizeDeployment(i, ['layout', 'allAddresses'])),
    };
}
exports.normalizeManifestData = normalizeManifestData;
function normalizeDeployment(input, include = []) {
    return (0, utils_general_1.pick)(input, ['address', 'txHash', ...include]);
}
//# sourceMappingURL=manifest.js.map