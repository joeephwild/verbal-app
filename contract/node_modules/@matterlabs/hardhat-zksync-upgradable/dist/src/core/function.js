"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertUnreachable = exports.getFunctionSignature = void 0;
const assert_1 = __importDefault(require("assert"));
function serializeParameterType(parameter, deref) {
    const { typeName, storageLocation } = parameter;
    (0, assert_1.default)(!!typeName);
    if (storageLocation === 'storage') {
        (0, assert_1.default)(typeof typeName.typeDescriptions.typeString === 'string');
        return `${typeName.typeDescriptions.typeString.replace(/^struct /, '')} storage`;
    }
    return serializeTypeName(typeName, deref);
}
function serializeTypeName(typeName, deref) {
    switch (typeName.nodeType) {
        case 'ArrayTypeName':
        case 'ElementaryTypeName': {
            (0, assert_1.default)(typeof typeName.typeDescriptions.typeString === 'string');
            return typeName.typeDescriptions.typeString;
        }
        case 'UserDefinedTypeName': {
            const userDefinedType = deref(['StructDefinition', 'EnumDefinition', 'ContractDefinition', 'UserDefinedValueTypeDefinition'], typeName.referencedDeclaration);
            switch (userDefinedType.nodeType) {
                case 'StructDefinition':
                    return `(${userDefinedType.members.map((member) => serializeParameterType(member, deref))})`;
                case 'EnumDefinition':
                    (0, assert_1.default)(userDefinedType.members.length < 256);
                    return 'uint8';
                case 'ContractDefinition':
                    return 'address';
                case 'UserDefinedValueTypeDefinition':
                    return serializeTypeName(userDefinedType.underlyingType, deref);
                default:
                    return assertUnreachable(userDefinedType);
            }
        }
        case 'FunctionTypeName': {
            return `function`;
        }
        default:
            throw new Error(`Unsuported TypeName node type: ${typeName.nodeType}`);
    }
}
function getFunctionSignature(fnDef, deref) {
    return `${fnDef.name}(${fnDef.parameters.parameters
        .map((parameter) => serializeParameterType(parameter, deref))
        .join()})`;
}
exports.getFunctionSignature = getFunctionSignature;
function assertUnreachable(_) {
    (0, assert_1.default)(false);
}
exports.assertUnreachable = assertUnreachable;
//# sourceMappingURL=function.js.map