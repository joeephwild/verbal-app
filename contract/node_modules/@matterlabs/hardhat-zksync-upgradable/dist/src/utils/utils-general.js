"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractFactoryDepsRecursive = exports.extractFactoryDeps = exports.loadArtifact = exports.convertGasPriceToEth = exports.extendCompilerOutputSelection = exports.isNullish = exports.isFullZkSolcOutput = exports.mapValues = exports.pick = exports.getContractCreationTxHash = exports.inferConstructorArgs = exports.getInitializerData = exports.getContractAddress = void 0;
const ethereumjs_util_1 = require("ethereumjs-util");
const ethers_1 = require("ethers");
const chalk_1 = __importDefault(require("chalk"));
const upgrades_core_1 = require("@openzeppelin/upgrades-core");
const constants_1 = require("../constants");
const errors_1 = require("../errors");
async function getContractAddress(addressOrInstance) {
    if (typeof addressOrInstance === 'string') {
        return addressOrInstance;
    }
    else {
        return await addressOrInstance.getAddress();
    }
}
exports.getContractAddress = getContractAddress;
function getInitializerData(contractInterface, args, initializer) {
    if (initializer === false) {
        return '0x';
    }
    const allowNoInitialization = initializer === undefined && args.length === 0;
    initializer = initializer ?? 'initialize';
    const fragment = contractInterface.getFunction(initializer);
    if (fragment === null) {
        if (allowNoInitialization) {
            return '0x';
        }
        else {
            throw new upgrades_core_1.UpgradesError(`The contract has no initializer function matching the name or signature: ${initializer}`, () => `Ensure that the initializer function exists, specify an existing function with the 'initializer' option, or set the 'initializer' option to false to omit the initializer call.`);
        }
    }
    else {
        return contractInterface.encodeFunctionData(fragment, args);
    }
}
exports.getInitializerData = getInitializerData;
/**
 * Gets the constructor args from the given transaction input and creation code.
 *
 * @param txInput The transaction input that was used to deploy the contract.
 * @param creationCode The contract creation code.
 * @returns the encoded constructor args, or undefined if txInput does not start with the creationCode.
 */
function inferConstructorArgs(txInput, creationCode) {
    return txInput.startsWith(creationCode) ? txInput.substring(creationCode.length) : undefined;
}
exports.inferConstructorArgs = inferConstructorArgs;
/**
 * Gets the txhash that created the contract at the given address, by calling the
 * RPC API to look for an event that should have been emitted during construction.
 *
 * @param provider The provider to use to call the RPC API.
 * @param address The address to get the creation txhash for.
 * @param topic The event topic string that should have been logged.
 * @returns The txhash corresponding to the logged event, or undefined if not found or if
 *   the address is not a contract.
 */
async function getContractCreationTxHash(provider, address, topic) {
    const params = {
        fromBlock: 'earliest',
        toBlock: 'latest',
        address,
        topics: [`0x${(0, ethereumjs_util_1.keccak256)(Buffer.from(topic)).toString('hex')}`],
    };
    const logs = await provider.getLogs(params);
    if (logs.length > 0) {
        return logs[0].transactionHash; // get the txhash from the first instance of this event
    }
    else {
        console.warn(chalk_1.default.yellow((0, constants_1.TOPIC_LOGS_NOT_FOUND_ERROR)(topic, address)));
    }
}
exports.getContractCreationTxHash = getContractCreationTxHash;
function pick(obj, keys) {
    const res = {};
    for (const k of keys) {
        res[k] = obj[k];
    }
    return res;
}
exports.pick = pick;
function mapValues(obj, fn) {
    const res = {};
    for (const k in obj) {
        if (!k)
            continue;
        res[k] = fn(obj[k]);
    }
    return res;
}
exports.mapValues = mapValues;
function isFullZkSolcOutput(output) {
    if (output?.contracts === undefined || output?.sources === undefined) {
        return false;
    }
    for (const fileName of Object.keys(output.contracts)) {
        const file = output.contracts[fileName];
        if (file === undefined) {
            return false;
        }
    }
    for (const file of Object.values(output.sources)) {
        if (file?.ast === undefined || file?.id === undefined) {
            return false;
        }
    }
    return true;
}
exports.isFullZkSolcOutput = isFullZkSolcOutput;
function isNullish(value) {
    return value === null || value === undefined;
}
exports.isNullish = isNullish;
function extendCompilerOutputSelection(compiler) {
    if (!compiler.settings.outputSelection['*']['*'].find((o) => o === 'storageLayout')) {
        compiler.settings.outputSelection['*']['*'].push('storageLayout');
    }
}
exports.extendCompilerOutputSelection = extendCompilerOutputSelection;
function convertGasPriceToEth(gasPrice) {
    return ethers_1.ethers.formatEther(gasPrice.toString());
}
exports.convertGasPriceToEth = convertGasPriceToEth;
async function loadArtifact(hre, contractNameOrFullyQualifiedName) {
    const artifact = await hre.artifacts.readArtifact(contractNameOrFullyQualifiedName);
    // Verify that this artifact was compiled by the zkSync compiler, and not `solc` or `vyper`.
    if (artifact._format !== constants_1.ZKSOLC_ARTIFACT_FORMAT_VERSION && artifact._format !== constants_1.ZKVYPER_ARTIFACT_FORMAT_VERSION) {
        throw new errors_1.ZkSyncUpgradablePluginError(`Artifact ${contractNameOrFullyQualifiedName} was not compiled by zksolc or zkvyper`);
    }
    return artifact;
}
exports.loadArtifact = loadArtifact;
async function extractFactoryDeps(hre, artifact) {
    const visited = new Set();
    visited.add(`${artifact.sourceName}:${artifact.contractName}`);
    return await extractFactoryDepsRecursive(hre, artifact, visited);
}
exports.extractFactoryDeps = extractFactoryDeps;
async function extractFactoryDepsRecursive(hre, artifact, visited) {
    // Load all the dependency bytecodes.
    // We transform it into an array of bytecodes.
    const factoryDeps = [];
    for (const dependencyHash in artifact.factoryDeps) {
        if (!dependencyHash)
            continue;
        const dependencyContract = artifact.factoryDeps[dependencyHash];
        if (!visited.has(dependencyContract)) {
            const dependencyArtifact = await loadArtifact(hre, dependencyContract);
            factoryDeps.push(dependencyArtifact.bytecode);
            visited.add(dependencyContract);
            const transitiveDeps = await extractFactoryDepsRecursive(hre, dependencyArtifact, visited);
            factoryDeps.push(...transitiveDeps);
        }
    }
    return factoryDeps;
}
exports.extractFactoryDepsRecursive = extractFactoryDepsRecursive;
//# sourceMappingURL=utils-general.js.map