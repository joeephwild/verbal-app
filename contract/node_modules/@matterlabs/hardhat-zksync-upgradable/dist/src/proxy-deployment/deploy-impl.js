"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deployBeaconImpl = exports.deployProxyImpl = exports.getDeployData = void 0;
const upgrades_core_1 = require("@openzeppelin/upgrades-core");
const options_1 = require("../utils/options");
const validate_impl_1 = require("../validations/validate-impl");
const validations_1 = require("../validations/validations");
const impl_store_1 = require("../core/impl-store");
const constants_1 = require("../constants");
const errors_1 = require("../errors");
const deploy_1 = require("./deploy");
async function getDeployData(hre, contractFactory, opts) {
    const provider = opts.provider;
    const validations = await (0, validations_1.readValidations)(hre);
    const unlinkedBytecode = contractFactory.bytecode;
    const encodedArgs = contractFactory.interface.encodeDeploy(opts.constructorArgs);
    const version = (0, upgrades_core_1.getVersion)(unlinkedBytecode, contractFactory.bytecode, encodedArgs);
    const layout = (0, upgrades_core_1.getStorageLayout)(validations, version);
    const fullOpts = (0, options_1.withDefaults)(opts);
    return {
        provider,
        validations,
        unlinkedBytecode,
        encodedArgs,
        version,
        layout,
        fullOpts,
    };
}
exports.getDeployData = getDeployData;
async function deployProxyImpl(hre, contractFactory, opts, proxyAddress) {
    const deployData = await getDeployData(hre, contractFactory, opts);
    await (0, validate_impl_1.validateProxyImpl)(deployData, opts, proxyAddress);
    return await deployImpl(hre, deployData, contractFactory, opts);
}
exports.deployProxyImpl = deployProxyImpl;
async function deployImpl(hre, deployData, factory, opts) {
    const layout = deployData.layout;
    const deployment = await (0, impl_store_1.fetchOrDeployGetDeployment)(deployData.version, deployData.provider, async () => {
        const abi = factory.interface.format(constants_1.FORMAT_TYPE_MINIMAL === 'minimal');
        const attemptDeploy = async () => {
            if (opts.useDeployedImplementation) {
                throw new errors_1.ZkSyncUpgradablePluginError(constants_1.IMPL_CONTRACT_NOT_DEPLOYED_ERROR);
            }
            else {
                const deployed = await (0, deploy_1.deploy)(factory, ...[
                    ...deployData.fullOpts.constructorArgs,
                    {
                        customData: {
                            factoryDeps: deployData.fullOpts.factoryDeps,
                            salt: 'salt' in opts
                                ? opts.salt
                                : opts.saltImpl,
                        },
                    },
                ]);
                return deployed;
            }
        };
        const deploymentInternal = { abi, ...(await attemptDeploy()) };
        return { ...deploymentInternal, layout };
    }, opts);
    return { impl: deployment.address, kind: opts.kind };
}
async function deployBeaconImpl(hre, factory, opts, beaconAddress) {
    const deployData = await getDeployData(hre, factory, opts);
    await (0, validate_impl_1.validateBeaconImpl)(deployData, opts, beaconAddress);
    return await deployImpl(hre, deployData, factory, opts);
}
exports.deployBeaconImpl = deployBeaconImpl;
//# sourceMappingURL=deploy-impl.js.map